<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Projects on Atharva Phadke</title><link>https://atharvap8.github.io/posts/ee-projects/</link><description>Recent content in Projects on Atharva Phadke</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>CC BY-NC 4.0</copyright><lastBuildDate>Fri, 28 Jan 2022 22:44:41 +0530</lastBuildDate><atom:link href="https://atharvap8.github.io/posts/ee-projects/index.xml" rel="self" type="application/rss+xml"/><item><title>BLE Based Car Security Controller</title><link>https://atharvap8.github.io/posts/2024/10/ble-based-car-security-controller/</link><pubDate>Wed, 30 Oct 2024 17:07:33 +0530</pubDate><guid>https://atharvap8.github.io/posts/2024/10/ble-based-car-security-controller/</guid><description>&lt;h1 id="central-locking-and-security-controller-for-wagon-r-with-esp32-and-ble">Central Locking and Security Controller for Wagon R with ESP32 and BLE&lt;/h1>
&lt;hr>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>This project showcases the development of a central locking and security controller for the Wagon R car, using Bluetooth Low Energy (BLE) technology. The system is based on an ESP32 microcontroller that handles key functionalities such as door signal control, bonnet status, indicators, and alarm settings. It is designed to work with a smartphone or a dedicated transmitter (built using the Xiao ESP32C3 board). Additionally, the system features an integrated immobilizer that communicates with the car’s ECM (Engine Control Module), preventing vehicle movement during theft attempts. The system also provides real-time alerts to the user&amp;rsquo;s cellphone in case of a security breach.&lt;/p></description><content type="html"><![CDATA[<h1 id="central-locking-and-security-controller-for-wagon-r-with-esp32-and-ble">Central Locking and Security Controller for Wagon R with ESP32 and BLE</h1>
<hr>
<h2 id="introduction">Introduction</h2>
<p>This project showcases the development of a central locking and security controller for the Wagon R car, using Bluetooth Low Energy (BLE) technology. The system is based on an ESP32 microcontroller that handles key functionalities such as door signal control, bonnet status, indicators, and alarm settings. It is designed to work with a smartphone or a dedicated transmitter (built using the Xiao ESP32C3 board). Additionally, the system features an integrated immobilizer that communicates with the car’s ECM (Engine Control Module), preventing vehicle movement during theft attempts. The system also provides real-time alerts to the user&rsquo;s cellphone in case of a security breach.</p>
<p>This solution enhances both the convenience and security of your vehicle, offering modern connectivity and control through BLE.</p>
<p><strong>[Video Tutorial Coming Soon]</strong></p>
<hr>
<h2 id="components-required">Components Required</h2>
<p>Here is a list of components needed to build the central locking and security system:</p>
<ul>
<li>ESP32 (Main controller for BLE and vehicle communication)</li>
<li>Xiao ESP32C3 (Transmitter for keyless entry)</li>
<li>Relays (for controlling door locks and indicators)</li>
<li>Immobilizer Circuit (connected to the car’s ECM)</li>
<li>Door and Bonnet Sensors (to detect door and bonnet status)</li>
<li>Alarm Module (for triggering alerts)</li>
<li>12V Power Supply (for powering the system)</li>
<li>LEDs (for status indication)</li>
<li>Jumper Wires</li>
<li>Connectors</li>
<li>PCB (for custom circuit design)</li>
<li>Breadboard (for testing)</li>
<li>Resistors, Diodes, Capacitors, etc.</li>
</ul>
<hr>
<h2 id="circuit-schematic-diagram">Circuit Schematic Diagram</h2>
<p>[]<br>
The diagram will show how the ESP32, sensors, immobilizer, Xiao ESP32C3 transmitter, and other components are connected.</p>
<hr>
<h2 id="pcb-design">PCB Design</h2>
<p>For the final product, you can design a custom PCB that integrates the ESP32 controller, relays, sensors, and communication circuits. This will make the setup more compact and reliable.</p>
<p>I have used EasyEDA software for PCB designing.</p>
<hr>
<h2 id="raw-media-files">Raw Media Files</h2>
<p>These are the raw unedited photos, videos, and prototype tests. Click Here:</p>
<p><a href="https://photos.app.goo.gl/32ChjenSaV4ZbyQp9"><img src="https://img.shields.io/badge/GooglePhotos-Album-blue?style=flat&amp;logo=Google%20Photos" alt="Static Badge"></a></p>
<hr>
<h2 id="how-it-works">How It Works</h2>
<ol>
<li>
<p><strong>Bluetooth Communication:</strong> The ESP32 serves as the main controller, using BLE to communicate with either the user&rsquo;s smartphone or the dedicated transmitter built with the Xiao ESP32C3. It manages lock/unlock signals, bonnet status, and alarm settings.</p>
</li>
<li>
<p><strong>Immobilizer Functionality:</strong> The system features an integrated immobilizer that communicates with the car’s ECM. In the event of a theft attempt, the immobilizer prevents the car from moving by cutting off ignition or other crucial systems.</p>
</li>
<li>
<p><strong>Real-time Alerts:</strong> In case of unauthorized access or forced entry, the system sends real-time notifications to the user’s cellphone via BLE. The user is alerted about the specific event, such as door status or bonnet being opened.</p>
</li>
<li>
<p><strong>Keyless Entry:</strong> The transmitter (Xiao ESP32C3) can be used as a physical keyless entry device, which allows the driver to unlock/lock the car without needing a physical key.</p>
</li>
<li>
<p><strong>Alarm System:</strong> When a security breach is detected, the alarm system is triggered, sounding an audible alert and notifying the user via phone.</p>
</li>
</ol>
<hr>
<h2 id="step-by-step-making-guide">Step-by-Step Making Guide</h2>
<h3 id="step-1-gather-components">Step 1: Gather Components</h3>
<p>Collect all the components listed above, ensuring you have the ESP32, Xiao ESP32C3, relays, and sensors.</p>
<h3 id="step-2-build-the-circuit-prototype">Step 2: Build the Circuit Prototype</h3>
<p>Start by connecting the ESP32 to the door sensors, relays, and the immobilizer circuit. Wire the transmitter using the Xiao ESP32C3. Test each connection using a breadboard.</p>
<h3 id="step-3-program-the-esp32-and-transmitter">Step 3: Program the ESP32 and Transmitter</h3>
<p>Using the Arduino IDE, program the ESP32 to manage door locking, bonnet status, BLE communication, and immobilizer functionality. Program the Xiao ESP32C3 transmitter to send lock/unlock signals to the ESP32.<br>
[Insert code or link to code here]</p>
<h3 id="step-4-install-in-the-car">Step 4: Install in the Car</h3>
<p>Once the prototype is tested and functional, install the system in your car. Mount the ESP32 and relays securely, and wire them to the car’s door lock actuators, bonnet sensors, and the ECM for immobilizer communication.</p>
<h3 id="step-5-test-the-system">Step 5: Test the System</h3>
<p>Test all functions: lock/unlock via smartphone and transmitter, immobilizer activation, alarm triggering, and real-time alerts. Ensure the system responds quickly to BLE commands and correctly handles door and bonnet status.</p>
<h3 id="step-6-design-and-assemble-the-pcb">Step 6: Design and Assemble the PCB</h3>
<p>For a cleaner installation, design a custom PCB to house the ESP32, relays, and related circuitry. Assemble and solder all components onto the PCB and reinstall it in the vehicle.</p>
<hr>
<h2 id="conclusion">Conclusion</h2>
<p>This central locking and security controller project adds an advanced layer of security to the Wagon R using BLE technology. The system allows for seamless keyless entry, enhanced vehicle immobilization during theft attempts, and real-time notifications to the user&rsquo;s cellphone. By using an ESP32 and Xiao ESP32C3, the system provides modern wireless control while ensuring reliability and security.</p>
<hr>
<h2 id="advantages">Advantages</h2>
<ul>
<li>Keyless entry via Bluetooth (phone or transmitter).</li>
<li>Integrated immobilizer that prevents vehicle movement in theft situations.</li>
<li>Real-time alerts to the user’s phone.</li>
<li>Works seamlessly with the vehicle&rsquo;s existing locking and alarm systems.</li>
<li>User-friendly design with a dedicated phone app for control.</li>
</ul>
<hr>
<h2 id="disadvantages">Disadvantages</h2>
<ul>
<li>Requires BLE-compatible phone for smartphone control.</li>
<li>Installation involves modifying the car&rsquo;s wiring, which may require automotive knowledge.</li>
<li>Dependent on Bluetooth range for functionality, which may limit control to nearby areas.</li>
</ul>
<hr>
<h2 id="future-scope-for-improvement">Future Scope for Improvement</h2>
<ul>
<li>Extend Bluetooth range with BLE mesh or add Wi-Fi connectivity for remote access.</li>
<li>Add GPS tracking to enhance vehicle recovery in case of theft.</li>
<li>Implement voice control via Google Assistant or Alexa.</li>
<li>Incorporate fingerprint or face recognition for enhanced security.</li>
<li>Add a battery backup to keep the system running even when the car&rsquo;s battery is disconnected.</li>
</ul>
<hr>
]]></content></item><item><title>IoT Based Gas Safety System</title><link>https://atharvap8.github.io/posts/2024/10/iot-based-gas-safety-system/</link><pubDate>Wed, 23 Oct 2024 17:27:02 +0530</pubDate><guid>https://atharvap8.github.io/posts/2024/10/iot-based-gas-safety-system/</guid><description>&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>In this project, we will build a comprehensive gas safety system designed to enhance household safety by monitoring gas leaks and taking automatic corrective actions. The system controls an exhaust fan, operates a servo motor to turn off the gas regulator, and sends notifications via email and popup alerts. Designed with robustness, fireproofing, data retention, and false alarm prevention in mind, this device provides reliable and continuous gas monitoring. Perfect for safety-conscious homeowners or DIY enthusiasts, this project helps to prevent potential hazards.&lt;/p></description><content type="html"><![CDATA[<h1 id="introduction">Introduction</h1>
<p>In this project, we will build a comprehensive gas safety system designed to enhance household safety by monitoring gas leaks and taking automatic corrective actions. The system controls an exhaust fan, operates a servo motor to turn off the gas regulator, and sends notifications via email and popup alerts. Designed with robustness, fireproofing, data retention, and false alarm prevention in mind, this device provides reliable and continuous gas monitoring. Perfect for safety-conscious homeowners or DIY enthusiasts, this project helps to prevent potential hazards.</p>
<hr>
<h2 id="youtube-video-link">Youtube Video Link</h2>
<h2 id="components-required">Components Required</h2>
<p>Here are the components you’ll need to build the gas safety system:</p>
<ul>
<li>ESP32 (for Wi-Fi connectivity and control)</li>
<li>MQ-2 Gas Sensor (for gas leak detection)</li>
<li>Servo Motor (for controlling the gas regulator)</li>
<li>Exhaust Fan (to ventilate the gas leak)</li>
<li>Relay Module (to control the exhaust fan)</li>
<li>Buzzer (for audible alerts)</li>
<li>Fireproof Casing (for added safety)</li>
<li>5V Power Supply</li>
<li>Jumper Wires</li>
<li>PCB (for the final circuit design)</li>
<li>Additional components: Resistors, Diodes, Capacitors, Transistors</li>
<li>Breadboard (for prototyping)</li>
</ul>
<hr>
<h2 id="circuit-schematic-diagram">Circuit Schematic Diagram</h2>
<p>[Insert your detailed circuit schematic diagram here]<br>
This schematic shows how the ESP32, gas sensor, servo motor, exhaust fan, and other components are connected.</p>
<hr>
<h2 id="pcb-design">PCB Design</h2>
<p>Once the prototype is working well, you can create a more permanent solution by designing a custom PCB. Here&rsquo;s the design I used:</p>
<hr>
<h2 id="project-media-folder">Project Media Folder</h2>
<h2 id="static-badge"><a href="https://photos.app.goo.gl/XcDekKXhq9hmfnH59"><img src="https://img.shields.io/badge/GooglePhotos-Album-blue?style=flat&amp;logo=Google%20Photos" alt="Static Badge"></a></h2>
<h2 id="how-it-works">How It Works</h2>
<p>The gas safety system continuously monitors gas levels using the MQ-2 gas sensor. If a gas leak is detected, the system immediately performs the following actions:</p>
<ol>
<li>The exhaust fan is triggered to remove gas from the environment.</li>
<li>The servo motor rotates to turn off the regulator on the gas cylinder.</li>
<li>Simultaneously, the ESP32 sends an email alert and a popup notification to the user’s mobile device via Wi-Fi.</li>
<li>A buzzer will sound to alert individuals in proximity.</li>
<li>Data retention and anti-false alarm measures ensure reliable operation. In case of sensor noise or minor fluctuations, the system intelligently filters out false triggers.</li>
</ol>
<hr>
<h2 id="step-by-step-making-guide">Step-by-Step Making Guide</h2>
<p><strong>Step 1: Gather All Components</strong><br>
Ensure you have all the components listed above, and prepare your workspace.</p>
<p><strong>Step 2: Build the Prototype Circuit</strong><br>
Start by connecting the MQ-2 gas sensor to the ESP32. Wire the servo motor, relay module, and buzzer to the appropriate pins on the ESP32. Use a breadboard for prototyping.</p>
<p><strong>Step 3: Program the ESP32</strong><br>
Using Arduino IDE, upload the code to the ESP32. The code includes functionality for controlling the servo motor, triggering the exhaust fan, and sending notifications.<br>
[Insert sample code or link to code here]</p>
<p><strong>Step 4: Test the System</strong><br>
Simulate a gas leak by introducing a small amount of gas near the MQ-2 sensor. The exhaust fan should turn on, and the servo motor should rotate to turn off the gas regulator. Ensure notifications are received via email and popup.</p>
<p><strong>Step 5: Design and Assemble the PCB</strong><br>
Once the prototype works correctly, design the PCB. After soldering the components onto the PCB, test the final circuit to ensure everything functions as expected.</p>
<p><strong>Step 6: Enclose in a Fireproof Casing</strong><br>
Install the system in a robust, fireproof casing for added protection. Ensure that the gas sensor is exposed to the environment while keeping other components shielded.</p>
<hr>
<h2 id="conclusion">Conclusion</h2>
<p>This gas safety system offers a robust, automated solution for gas leak detection and prevention. By using easily accessible components, this project provides peace of mind with its reliable, responsive actions in hazardous conditions. With Wi-Fi connectivity, real-time notifications, and a fireproof design, it’s a perfect DIY solution for enhancing home safety.</p>
<hr>
<h2 id="advantages">Advantages</h2>
<ul>
<li>Automated response to gas leaks (exhaust fan and gas regulator control).</li>
<li>Real-time email and popup notifications.</li>
<li>Fireproof and robust design for safe use.</li>
<li>False alarm prevention with data retention features.</li>
<li>Can be monitored remotely through Wi-Fi.</li>
</ul>
<hr>
<h2 id="disadvantages">Disadvantages</h2>
<ul>
<li>Requires stable Wi-Fi connectivity for notifications.</li>
<li>The servo motor may require occasional maintenance to ensure smooth operation.</li>
<li>Initial setup may be complex for beginners.</li>
</ul>
<hr>
<h2 id="future-scope-for-improvement">Future Scope for Improvement</h2>
<ul>
<li>Integration with smart home systems such as Google Home or Alexa.</li>
<li>Battery backup to keep the system running during power outages.</li>
<li>Addition of an LCD screen to display gas levels and system status.</li>
<li>Further optimization of false alarm filtering algorithms.</li>
</ul>
<hr>
]]></content></item><item><title>ESP32 Based Washing Machine</title><link>https://atharvap8.github.io/posts/2024/07/esp32-based-washing-machine/</link><pubDate>Mon, 29 Jul 2024 18:00:32 +0530</pubDate><guid>https://atharvap8.github.io/posts/2024/07/esp32-based-washing-machine/</guid><description>&lt;h1 id="coming-soon">&lt;strong>Coming SOON!&lt;/strong>&lt;/h1></description><content type="html">&lt;h1 id="coming-soon">&lt;strong>Coming SOON!&lt;/strong>&lt;/h1>
</content></item><item><title>Automatic Water Tap V2</title><link>https://atharvap8.github.io/posts/2024/06/automatic-water-tap-v2/</link><pubDate>Sun, 23 Jun 2024 12:57:02 +0530</pubDate><guid>https://atharvap8.github.io/posts/2024/06/automatic-water-tap-v2/</guid><description>&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>In this project, I have built an IR Sensor-based automatic water tap. This system allows water to flow when it detects an object in front of the sensor, making it a convenient and hygienic solution for home or public restrooms. The IR sensor is mounted on the tap head to detect any objects near the water tap.&lt;/p>
&lt;h2 id="youtube-video">YouTube Video&lt;/h2>
&lt;p>Here&amp;rsquo;s the project&amp;rsquo;s youtube video link:
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/RHL07T6kZwI?autoplay=0&amp;amp;controls=1&amp;amp;end=0&amp;amp;loop=0&amp;amp;mute=0&amp;amp;start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video">&lt;/iframe>
&lt;/div>
&lt;/p></description><content type="html"><![CDATA[<h1 id="introduction">Introduction</h1>
<p>In this project, I have built an IR Sensor-based automatic water tap. This system allows water to flow when it detects an object in front of the sensor, making it a convenient and hygienic solution for home or public restrooms. The IR sensor is mounted on the tap head to detect any objects near the water tap.</p>
<h2 id="youtube-video">YouTube Video</h2>
<p>Here&rsquo;s the project&rsquo;s youtube video link:
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/RHL07T6kZwI?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"></iframe>
    </div>
</p>
<h2 id="components-required">Components Required</h2>
<ul>
<li>IR Sensor Module</li>
<li>12V Solenoid Valve</li>
<li>PNP Transistor: BD140</li>
<li>Resistor: 10kΩ, 1/4Watt, ±5%</li>
<li>Diode: 1N4007 General Purpose Diode</li>
<li>Power Supply (230V AC to 12V DC)</li>
<li>Mini 360 Buck Converter</li>
<li>D4184 Mosfet Control Module</li>
<li>Connecting Wires</li>
<li>Enclosure</li>
<li>Screws, Zip Ties, Piping, etc.</li>
<li>Water Tap</li>
</ul>
<h2 id="circuit-diagram">Circuit Diagram</h2>
<figure><img src="/img/automatic_water_tap.jpg">
</figure>

<h2 id="project-media">Project Media</h2>
<p>Click Here:</p>
<p><a href="https://photos.app.goo.gl/nLhd8z81mfEargJE8"><img src="https://img.shields.io/badge/GooglePhotos-Album-greenCl" alt="Static Badge"></a></p>
<h2 id="how-it-works">How It Works</h2>
<p>The automatic water tap works based on the principle of Infrared (IR) detection. Here&rsquo;s a concise theory of its operation:</p>
<ol>
<li><strong>IR Sensor Module</strong>: The IR sensor emits infrared light. When an object comes within the sensor&rsquo;s range, the emitted light reflects back to the sensor.</li>
<li><strong>Signal Processing</strong>: The sensor detects the reflected IR light and sends a signal to the connected circuit.</li>
<li><strong>MOSFET Control</strong>: The received signal is used to activate a MOSFET. It acts as a switch to control the solenoid valve.</li>
<li><strong>Solenoid Valve Operation</strong>: When the MOSFET is activated, it allows current to flow through the solenoid valve, opening it and letting water flow.</li>
<li><strong>Water Flow</strong>: The water flows as long as the object is detected by the IR sensor. Once the object is removed, the sensor stops detecting the reflection, and the solenoid valve closes, stopping the water flow.</li>
</ol>
<h2 id="step-by-step-guide">Step-by-Step Guide</h2>
<ol>
<li>
<p><strong>Prepare the enclosure:</strong></p>
<ul>
<li>Drill 2 holes into the plastic enclosure, to be able to mount it to a wall.</li>
<li>Drill additional holes to mount the components, you can use zip ties, or screw + clamps.</li>
<li>Drill required holes to pass the incoming and outgoing wires.</li>
</ul>
</li>
<li>
<p><strong>Circuit Connections:</strong></p>
<ul>
<li>Connect the components, according to the wiring diagram shown above.</li>
<li>Do make sure to use heat shrink tubing, to avoid short circuit.</li>
</ul>
</li>
<li>
<p><strong>Connect the Solenoid Valve:</strong></p>
<ul>
<li>Connect the solenoid valve wires, to its terminals.</li>
<li>Connect the solenoid valve, with one end to the water tap inlet, and other end to the source.</li>
<li>Keep in mind, the solenoid valve direction.</li>
<li>If connected in reverse, the solenoid valve will either flow continuously, or won&rsquo;t work at all.</li>
</ul>
</li>
<li>
<p><strong>Tap Connections:</strong></p>
<ul>
<li>Attach a layer strip of insulation tape to the back of the sensor module PCB.</li>
<li>Attach a double sided tape on top of the insulation tape, and press it firmly.</li>
<li>Position the sensor, and stick it underside of the tap.</li>
<li>Align the transmitter and receiver LEDs, so as to properly set the control area.</li>
<li>attach a layer of insulation tape around the sensor pcb and tap. As shown in the video.</li>
</ul>
</li>
<li>
<p><strong>First Time Power-Up:</strong></p>
<ul>
<li>After properly checking the connections, turn on the power to the circuit.</li>
</ul>
</li>
<li>
<p><strong>Calibrate the Sensor:</strong></p>
<ul>
<li>Adjust the sensor position, angle, to have the desired control position.</li>
</ul>
</li>
<li>
<p><strong>Test the Operation:</strong></p>
<ul>
<li>Place your hand in front of the tap. The sensor should detect your hand and open the solenoid valve, allowing water to flow.</li>
<li>Remove your hand to stop the water flow.</li>
</ul>
</li>
</ol>
<h2 id="conclusion">Conclusion</h2>
<p>This IR sensor-based automatic water tap project is an excellent way to enhance hygiene and convenience in both home and public restrooms. By automating the water flow, you can minimize water wastage and prevent the spread of germs through touch. Being cost effective, and easy to build, anyone interested, can make it.</p>
]]></content></item><item><title>Advanced IoT Washing Machine</title><link>https://atharvap8.github.io/posts/2024/06/advanced-iot-washing-machine/</link><pubDate>Fri, 07 Jun 2024 17:57:12 +0530</pubDate><guid>https://atharvap8.github.io/posts/2024/06/advanced-iot-washing-machine/</guid><description>&lt;p>&lt;strong>⚠️ Warning: Extreme High Voltage Risk!&lt;/strong>&lt;/p>
&lt;p>&lt;strong>This project involved working with mains, and rectified 325V DC, such voltage levels are more than lethal.&lt;/strong>&lt;br>
&lt;strong>Appropriate safety measures were taken, and proper safety gear was used, including the use of current-limiting lamps, isolation circuits, and staged testing procedures.&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Readers attempting similar projects MUST have a strong understanding of electrical safety and always work under supervision if inexperienced.&lt;/strong>&lt;/p>
&lt;h2 id="-introduction">📘 Introduction&lt;/h2>
&lt;p>This project chronicles the transformation of a non-functional &lt;em>LG fully automatic washing machine&lt;/em> into a modern, intelligent, and voice-controlled appliance using &lt;strong>ESP32 microcontroller, relays, sensors, and Alexa integration.&lt;/strong> The machine’s &lt;strong>original controller PCB had failed&lt;/strong>, providing an opportunity to take full control of the machine’s sophisticated components and create a customisable system from the ground up.&lt;/p></description><content type="html"><![CDATA[<p><strong>⚠️ Warning: Extreme High Voltage Risk!</strong></p>
<p><strong>This project involved working with mains, and rectified 325V DC, such voltage levels are more than lethal.</strong><br>
<strong>Appropriate safety measures were taken, and proper safety gear was used, including the use of current-limiting lamps, isolation circuits, and staged testing procedures.</strong></p>
<p><strong>Readers attempting similar projects MUST have a strong understanding of electrical safety and always work under supervision if inexperienced.</strong></p>
<h2 id="-introduction">📘 Introduction</h2>
<p>This project chronicles the transformation of a non-functional <em>LG fully automatic washing machine</em> into a modern, intelligent, and voice-controlled appliance using <strong>ESP32 microcontroller, relays, sensors, and Alexa integration.</strong> The machine’s <strong>original controller PCB had failed</strong>, providing an opportunity to take full control of the machine’s sophisticated components and create a customisable system from the ground up.</p>
<hr>
<hr>
<h2 id="-background--motivation">🎯 Background &amp; Motivation</h2>
<p>After the machine&rsquo;s original controller board went haywire, instead of discarding it, I saw the opportunity to understand and reengineer the device. With full access to all internal components (motor, valves, sensors), this project became an intensive 1-year journey through reverse engineering, signal probing, embedded firmware design, IoT integration, mechanical testing, and finally full automation.</p>
<hr>
<hr>
<h2 id="-complete-disassembly--mechanical-understanding">🔧 Complete Disassembly &amp; Mechanical Understanding</h2>
<ul>
<li>
<p>First I started by taking the entire drum and motor assembly apart. I literally removed every component and part, such as the suspension arms, The Drain Motor assembly, the gearbox transmission system, The motor assembly.</p>
</li>
<li>
<p>The top cover was removed, and the required wiring connectors were disconnected, so as to completely separate the top housing cover. Then the drum assembly was taken out.</p>
</li>
<li>
<p>What I did afterwards is, I had a 3 phase VFD (Variable Frequency Drive). Using it, I started to test the motor with various frequecies, and observed the RPM of the motor at different frequency.</p>
</li>
<li>
<p>Next test was to properly test if the drum brake disengage mechanism was working or not. To test it, I had to apply 12 V to the drain Motor. There i realized, it had 3 pins, 1 is GND (Ground), 2 is Wash Mode, 3 is Spin Mode.</p>
</li>
<li>
<p>By applying 12V DC to specified terminal, i tested the drain motor. And confirmed that the drum also starts to spin.</p>
</li>
</ul>
<figure><img src="/img/aiotwm/drainmotor.jpeg"
    alt="Drain Motor" width="800px" height="400px"><figcaption>
      <p>Drain Motor</p>
    </figcaption>
</figure>

<hr>
<hr>
<h2 id="-reverse-engineering-the-inverter-drive-module">🧠 Reverse Engineering the Inverter Drive Module</h2>
<figure><img src="/img/aiotwm/module.jpg"
    alt="Inverter Drive Module (Model: ISB-LC4-3050_V2)" width="900px" height="500px"><figcaption>
      <p><strong><em>Inverter Drive Module (Model: ISB-LC4-3050_V2)</em></strong></p>
    </figcaption>
</figure>

<ul>
<li>
<p>Before connecting the module to anything, I conducted a thorough short-circuit and continuity test on the IPM board to ensure that it hadn’t suffered damage or latent failures. Only after verifying its integrity did I proceed with functional testing.</p>
</li>
<li>
<p>The inverter module contains an Infineon IGCM04G60HA Intelligent Power Module (<a href="https://eepower.com/technical-articles/intelligent-power-modules-ipms-concepts-features-and-applications" title="Detailed Info"><strong>IPM</strong></a>) along with a Renesas UPD78F1201 16-bit microcontroller, originally used in Samsung dual-door refrigerators to control the BLDC compressor motor.</p>
</li>
<li>
<p>I began reverse engineering the control logic by tracing the input terminals and signal paths on the board. It was quickly evident that this module was far more sophisticated than a basic relay driver — it had full embedded PWM-based motor control logic built into the microcontroller.</p>
</li>
<li>
<p>The IPM requires an external 325V DC power rail, typically obtained by rectifying and filtering the 230V AC mains using a high-voltage bridge rectifier and bulk electrolytic capacitors. This high-voltage rail is then switched across the motor windings using high-side and low-side IGBTs inside the IPM, forming a standard three-phase inverter topology.</p>
</li>
<li>
<p>One of the unique behaviors I discovered during testing was the module’s built-in soft-start delay: it waits for nearly 10 minutes after power is applied before automatically enabling motor output. This likely replicates the refrigeration compressor’s anti-short-cycling feature. After the wait, the board autonomously initialized and began spinning the motor, confirming that it was operational.</p>
</li>
<li>
<p>During this process, I connected the motor externally and used a series filament lamp to limit inrush current and provide a visual cue for abnormal current draw — a tried-and-tested method in electronics repair. This prevented catastrophic failure in case of internal shorts or miswiring.</p>
</li>
<li>
<p>The motor began spinning smoothly with considerable torque — to the extent that I could not stop it by hand. The board was operating as expected, safely handling the start-up, speed regulation, and directional switching.</p>
</li>
</ul>
<h2 id="-understanding-motor-drive-logic-3-phase-inverter-motor">⚙️ Understanding Motor Drive Logic (3-Phase Inverter Motor)</h2>
<ul>
<li>The motor was a typical 3-Phase UVW Motor, with a rated Voltage of 310V DC. Also it was specially designed for LG.</li>
</ul>
<figure><img src="/img/aiotwm/uvwmotor.jpg"
    alt="BLDC Motor - (Part No. WDC0150Y1M)" width="400px" height="250px"><figcaption>
      <p><strong>BLDC Motor - (Part No. WDC0150Y1M)</strong></p>
    </figcaption>
</figure>

<ul>
<li>
<p>Once the motor was verified to run standalone, I mounted it inside the washing machine drum and connected it to the mechanical assembly responsible for spin and wash motion. This allowed me to test realistic load behavior.</p>
</li>
<li>
<p>I loaded the drum with wet clothes and triggered a spin sequence. The motor was powerful enough to sustain the load without stalling — demonstrating that the Samsung IPM board’s output stage was capable of delivering commercial-level torque, even under load conditions typical for a full spin cycle.</p>
</li>
<li>
<p>I studied the motor’s feedback and control wiring in more detail. It used a 4-pin connector, <strong>responsible for:</strong></p>
<ul>
<li><em>Providing Motor RPM (Speed) Values (using Feedback)</em></li>
<li><em>Providing PWM Speed Control to the IPM board</em></li>
<li><em>Sending Fault Status and Response Codes</em></li>
</ul>
</li>
<li>
<p>The core of the operation lies in the alternating high-voltage switching of the three-phase windings, based on precise rotor position sensing. This allows the motor to operate in synchronous mode, with smooth startup, speed variation, and directional control.</p>
</li>
</ul>
<figure><img src="/img/aiotwm/modblkdia.png"
    alt="Inverter Drive Module (Model: ISB-LC4-3050_V2) Block Diagram" width="900px" height="500px"><figcaption>
      <p><strong><em>Inverter Drive Module (Model: ISB-LC4-3050_V2) Block Diagram</em></strong></p>
    </figcaption>
</figure>

<hr>
<hr>
<h2 id="-prototyping-with-arduino-uno">🧪 Prototyping with Arduino UNO</h2>
<ul>
<li>To test manual control over the IPM board, I designed a basic PWM signal generator using an Arduino UNO. The idea was to simulate the kind of PWM signals the original fridge controller might have sent to the IPM board.</li>
</ul>
<p><strong>Video Link:</strong> <a href="https://photos.google.com/share/AF1QipPNWp27gQstlgL91O9z6UTNsfqDp0jNiJFLL1oh2fxKv0CKhDPo4cSU1hQcb7W5Ug/photo/AF1QipNVxxiq89uGjgkWxa-xYKltjGWV_kP-2nztHGkK?key=WE9fbWNub0hjMVVGcDI5YVAwNG5lRzgwblA3Qm1B"><strong>Click Here</strong></a></p>
<ul>
<li>
<p>The PWM signal was routed through an optocoupler to safely interface the 5V Arduino with the IPM’s control logic. This allowed me to control motor start/stop by sending short PWM bursts after the initial soft-start period.</p>
</li>
<li>
<p>Next, I experimented with variable PWM duty cycles and frequency modulation. This helped test the motor speed control behavior — I could observe changes in spin RPM as I adjusted the duty cycle from ~20% to ~90%.</p>
</li>
<li>
<p>This step confirmed that the motor’s speed could be externally controlled via software-generated PWM, laying the groundwork for future integration with the ESP32, which would replace the Arduino in the final system.</p>
</li>
<li>
<p>The prototype circuit also included simple time delay routines to prevent sudden starts, giving the inverter enough time to safely initialize before sending control signals.</p>
</li>
</ul>
<hr>
<hr>
<h2 id="-actuator-testing--verification">🔌 Actuator Testing &amp; Verification</h2>
<ul>
<li>
<p>To ensure that each electromechanical component of the washing machine functioned independently and predictably, I began by testing the actuators one by one using a bench power supply set to 12V DC. This direct testing allowed me to characterize their behavior under controlled conditions.</p>
</li>
<li>
<p><strong>Inlet Valve Solenoid:</strong>
Applying 12V to the inlet valve triggered the internal solenoid, allowing water to flow through the valve — confirming its normal operation. This validated that the solenoid did not have internal clogs or sticking.
Test Video: <a href="https://photos.google.com/share/AF1QipPNWp27gQstlgL91O9z6UTNsfqDp0jNiJFLL1oh2fxKv0CKhDPo4cSU1hQcb7W5Ug/photo/AF1QipNyLZyQe0GKYjuD5GXr5bdJehANY0eZp5mWon2a?key=WE9fbWNub0hjMVVGcDI5YVAwNG5lRzgwblA3Qm1B"><strong>Cick Here</strong></a></p>
</li>
<li>
<p><strong>Drain Motor – Stage 1 (Power Wash Mode):</strong>
In this stage, a partial stroke of the drain motor disengages the half-drum brake, enabling gentle rotation for washing. On applying power, the actuator moved correctly to this intermediate position.</p>
</li>
<li>
<p><strong>Drain Motor – Stage 2 (Spin Mode):</strong><br>
A longer actuation engaged the drain motor fully, which completely disengaged the drum brake, allowing high-speed rotation for spin cycles. This also worked reliably and repeatedly.</p>
</li>
</ul>
<p>These tests formed the foundation for mapping the mechanical behavior of the machine&rsquo;s internal mechanisms with external electrical control, enabling fully customized programming of future washing sequences.</p>
<hr>
<hr>
<h2 id="-closed-loop-water-level-regulation">🔄 Closed-Loop Water Level Regulation</h2>
<p>To automate water level management, I initially explored both analog and digital pressure sensing techniques. While analog sensors lacked precision and required additional ADC circuitry, most commercial digital pressure sensors were expensive and difficult to source.</p>
<ul>
<li>After some research, I discovered the <strong>HX710B</strong>, a pressure sensor IC derived from the popular HX711 load cell amplifier family. Though not originally intended for environmental sensing, the HX710B has a differential ADC interface capable of measuring small voltage differences with high resolution — making it suitable for repurposing as a water-level pressure sensor.</li>
</ul>
<figure><img src="/img/aiotwm/aps.jpg"
    alt="HX710B Air Pressure Sensor" width="300px" height="300px"><figcaption>
      <p>HX710B Air Pressure Sensor</p>
    </figcaption>
</figure>

<p><strong>Test Setup:</strong></p>
<ul>
<li>
<p>I connected the HX710B to a small air trap chamber — this chamber is connected to the bottom of the drum via a sealed air tube.</p>
</li>
<li>
<p>As the water fills the drum, the air inside the trap compresses, increasing the internal pressure, which is detected by the HX710B module.</p>
</li>
<li>
<p>A simple Arduino sketch continuously read the digital values from the HX710B and compared them against predefined setpoints.</p>
</li>
<li>
<p>Calibration was performed manually using graduated containers to add specific volumes of water. I logged corresponding sensor readings to correlate digital values with actual water levels (e.g., 6L, 12L, 18L).</p>
</li>
</ul>
<hr>
<hr>
<h2 id="-transitioning-to-esp32-platform">🔁 Transitioning to ESP32 Platform</h2>
<ul>
<li>Once the core testing of motor control and actuator behavior was completed, I shifted focus to building a more intelligent, fully programmable controller. This began with selecting the appropriate microcontroller platform.</li>
</ul>
<p><strong>Microcontroller Selection:</strong></p>
<ul>
<li>After estimating the number of GPIOs required for relay modules, sensors, communication interfaces, and feedback mechanisms, I finalized the ESP32 as the brain of the system.</li>
</ul>
<p><strong>The ESP32 provided:</strong></p>
<ul>
<li>Dual-core processing for multitasking wash logic and communications.</li>
<li>Sufficient digital I/O and ADC inputs.</li>
<li>Built-in Wi-Fi and Bluetooth, enabling smart integration features.</li>
</ul>
<p><strong>Platform Setup and Firmware Development:</strong></p>
<ul>
<li>I opted for the ESP-IDF (Espressif IoT Development Framework) to build the firmware, ensuring full control and lower-level access compared to Arduino Core.</li>
</ul>
<p><strong>Initial libraries integrated:</strong></p>
<ul>
<li>
<p><strong>HX711/HX710B</strong> for water level sensing.</p>
</li>
<li>
<p><strong>Telegram Bot</strong> Library to push real-time updates to my personal Telegram bot.</p>
</li>
<li>
<p><strong>Wire / I2C / GPIO</strong> drivers for low-level control of peripherals.</p>
</li>
<li>
<p><strong>WebServer</strong> Library for Endpoint control, and OTA Update Framework.</p>
</li>
<li>
<p><strong>ElegantOTA</strong> Library for Backend OTA Handling.</p>
</li>
<li>
<p><strong>LiquidCrystalI2C</strong> Library for Displaying text on 16x2 LCD.</p>
</li>
<li>
<p><strong>Espalexa Library</strong> for Remote Device Control.</p>
</li>
<li>
<p>All control logic — including PWM generation, relay sequencing, safety interlocks, and mode switching — was implemented as tasks within the ESP32’s FreeRTOS framework.</p>
</li>
</ul>
<hr>
<hr>
<h2 id="-mechanical-load-testing">🧱 Mechanical Load Testing</h2>
<ul>
<li>With firmware ready and control logic functional, I moved on to real-world mechanical stress testing to validate the full load capabilities of the inverter drive and the motor.</li>
</ul>
<p><strong>⚙️ Full Drum Load Testing:</strong></p>
<ul>
<li>I mounted the motor inside the washing drum, reassembled the mechanical linkage, and filled the drum with clothes and water to simulate real conditions.</li>
<li>Using different PWM duty cycles, I controlled the motor through wash, rinse, and spin modes.</li>
<li>Peak power output observed was approximately 350W sustained, with startup torque high enough that manual interruption was impossible — indicating the IPM was operating optimally.</li>
</ul>
<p><strong>🚨 Error Handling Observations:</strong></p>
<ul>
<li>During testing, unexpected shutdowns occurred. After careful diagnosis, I discovered a protection feature in the inverter module:</li>
<li>If a single changeover relay (used for phase reversal) was left ON while the inverter supply was active, the UVW outputs got shorted.</li>
<li>This triggered the IPM’s internal short-circuit protection (OCP), causing the module to shut down.</li>
<li>I updated the code logic to ensure relays disengage cleanly before power-down, preventing inadvertent fault conditions.</li>
</ul>
<hr>
<hr>
<h2 id="-custom-pcb-design--wiring-integration">🧯 Custom PCB Design &amp; Wiring Integration</h2>
<p>Once the electronics and code were verified on breadboards and modules, I moved to permanent installation inside the washing machine.</p>
<p><strong>Hardware Design and Assembly:</strong></p>
<p>Created a detailed schematic, including:</p>
<ul>
<li>
<p>Relay driver modules</p>
</li>
<li>
<p>Isolated optocoupler inputs for IPM signals</p>
</li>
<li>
<p>Buck converters for powering logic</p>
</li>
<li>
<p>Sensor headers for HX710B, inlet valve, and drain motor</p>
</li>
<li>
<p>Due to unavailability of quick-turn PCB fabrication services, I hand-built the board on a general-purpose zero PCB, following the schematic.</p>
</li>
</ul>
<p><strong>Testing &amp; Installation:</strong></p>
<ul>
<li>All components were tested during assembly to ensure there were no solder bridges or open circuits.</li>
<li>I labeled each wire and crimped all terminal ends to ensure proper fit inside screw terminals.</li>
<li>Cutouts and holes were drilled into the top cover panel and a side-mounted junction box was added to house the control PCB safely.</li>
</ul>
<p><strong>Wiring Scheme:</strong></p>
<ul>
<li>
<p><strong>3 motor wires:</strong></p>
<ul>
<li>1 directly connected to the motor</li>
<li>2 routed through changeover relays to switch phases</li>
<li>2 wires to inverter drive:</li>
<li>Live (through relay NO + COM terminals)</li>
<li>Neutral (direct to inverter drive)</li>
</ul>
</li>
<li>
<p><strong>Remaining relay channels controlled:</strong></p>
<ul>
<li>Drain Motor Stage 1</li>
<li>Drain Motor Stage 2</li>
<li>Inlet Valve</li>
<li>Changeover Relays</li>
</ul>
</li>
<li>
<p>For detailed wiring and notes, refer the schematic circuit diagram, and stock wiring diagram of the machine.</p>
</li>
</ul>
<hr>
<hr>
<h2 id="-front-panel-design--development">🎛️ Front Panel Design &amp; Development</h2>
<p>Designing the front panel was not just an aesthetic decision — it was a critical component in delivering a functional, reliable, and user-friendly interface for the retrofitted washing machine. With no original UI board functioning (due to the faulty LG controller), the entire interface had to be redesigned from scratch, keeping in mind ergonomics, electrical isolation, display clarity, and accessibility.</p>
<p><strong>🧱 1. Layout Planning</strong></p>
<p>The design process started with a rough sketch of all the <strong>necessary</strong> interface elements:</p>
<ul>
<li>Main display (LCD 16x2 or OLED).</li>
<li>Tactile input buttons (Mode, Start, Reset).</li>
<li>LED indicators for system states.</li>
<li>Emergency stop provision.</li>
<li>Access ports for OTA/Debug (e.g., USB/FTDI header)</li>
<li>Cutouts for ventilation and labeling.</li>
</ul>
<p>The goal was to <strong>ensure:</strong></p>
<ul>
<li>Minimum clutter.</li>
<li>Maximum information at a glance.</li>
<li>Separation between low-voltage ESP32 logic and high-voltage relay controls.</li>
</ul>
<hr>
<p><strong>🧩 2. Component Selection &amp; Positioning</strong></p>
<p>Each panel component was chosen based on usability and reliability:</p>
<ul>
<li>Element	Reason.</li>
<li>Tactile Push Buttons	Easy to mount, long life, ideal for mode switching.</li>
<li>16x2 LCD Display	Cost-effective, clear status updates.</li>
<li>Status LEDs	For real-time visual feedback: power, mode, error, operation.</li>
<li>Panel-Mount Connectors	For 5V DC input, USB debug, and potential serial interfaces.</li>
</ul>
<p>All components were mounted on a common plastic/acrylic sheet, which was cut and drilled manually to fit each device precisely.</p>
<hr>
<p><strong>🧷 3. Wiring &amp; Assembly</strong></p>
<p>Behind the front panel:</p>
<ul>
<li>All button presses were connected via pull-down resistors to GPIOs.</li>
<li>LEDs were driven using current-limiting resistors and GPIOs.</li>
<li>Display was connected via I2C (SCL/SDA), allowing minimal pin usage.</li>
<li>Proper strain reliefs and wire harnessing were added to avoid accidental disconnections.</li>
</ul>
<p>Each wire was labeled and color-coded. Terminal blocks or screw connectors were used where possible, ensuring modularity during maintenance or updates.</p>
<p><strong>🧰 4. Enclosure Integration</strong></p>
<p>The final panel was:</p>
<p>Mounted on the side wall of the washing machine (junction box style).
Designed for easy access even while machine was running.
Provided with ventilation slots to prevent overheating of onboard electronics.
Screwed and sealed to prevent accidental contact with internal high-voltage parts.</p>
<hr>
<p><strong>📟 5. Display Logic</strong></p>
<p>The UI logic was written in ESP32 firmware:</p>
<p>Idle screen shows “Please Select A Program”</p>
<p>Active screen scrolls between:</p>
<ul>
<li>Current mode.</li>
<li>Water level.</li>
<li>Time remaining.</li>
<li>Error/warning messages.</li>
<li>Error conditions trigger blinking patterns and special alerts.</li>
</ul>
<hr>
<p><strong>🧪 6. Testing &amp; Feedback</strong></p>
<p>After panel assembly:</p>
<ul>
<li>Every button and LED was tested individually for debounce behavior.</li>
<li>Display visibility was checked under different lighting conditions.</li>
<li>Labels were added using sticker paper or engraved plate to show functions clearly.</li>
<li>Final touch: Added support for firmware OTA updates through a physical button combo.</li>
</ul>
<hr>
<hr>
<h2 id="-implemented-features">✅ Implemented Features</h2>
<ul>
<li>Basic Washing Programs</li>
<li>Water Level Sensing</li>
<li>Wi-Fi Enabled Control</li>
<li>Live Status Indication</li>
<li>Voice Assistant Integration</li>
<li>Web Dashboard Control</li>
<li>OTA Firmware Update</li>
<li>Partial Error Handling</li>
<li>Manual Control Panel</li>
<li>Status LEDs</li>
<li>Telegram Notification Bot</li>
<li>LCD Display Feedback</li>
</ul>
<hr>
<hr>
<h2 id="-features-under-development">🛠️ Features Under Development</h2>
<ul>
<li>Countdown Timer Display</li>
<li>Emergency Inverter Stop</li>
<li>Custom IC-Based PCB Design</li>
<li>Custom Inverter Drive Design</li>
<li>Wash Cycle Memory Function</li>
<li>Auto Resume After Power Loss</li>
<li>Door Safety Interrupt</li>
<li>Load Sensing &amp; Auto Balancing</li>
<li>Smart Error Diagnosis &amp; Suggestions</li>
<li>AI Self-Diagnostic System</li>
<li>Test Mode (Self-Run)</li>
<li>AI-Based Laundry Type Detection</li>
<li>Dynamic Water Level by Load</li>
<li>Water Heater &amp; Temperature Sensing</li>
</ul>
<hr>
<hr>
<h2 id="-challenges--failures">⚠️ Challenges &amp; Failures</h2>
<p><strong>1. 🧠 Understanding the Inverter Drive — Blind Reverse Engineering</strong></p>
<p>At the start, the inverter module (Samsung ISB-LC4-3050_V2) was a black box. No schematics, no documentation, no datasheets. Just a 325V input and a four-pin connector to a washing machine motor. Through painstaking trial and error, I reverse-engineered:</p>
<ul>
<li><strong>The function of feedback pins.</strong></li>
<li><strong>How the module self-starts after a 10-minute delay.</strong></li>
<li><strong>How it interprets PWM signals for speed control.</strong></li>
</ul>
<p>This eventually led to block diagrams, signal maps, and logic sequences that were key to system integration.</p>
<hr>
<p><strong>2. 🔄Motor Direction and Speed Control</strong></p>
<p>Getting the motor to spin wasn’t enough. Controlling its direction and speed was the next major challenge.</p>
<ul>
<li><strong>Direction control required safe relay-based phase inversion.</strong></li>
<li><strong>Speed control required precise PWM signal timing.</strong></li>
</ul>
<p>I went through dozens of PWM timing experiments, finally landing on a sweet spot that gave the motor smooth acceleration without tripping inverter protections.</p>
<hr>
<p><strong>3. 🌊 Water Level Control Loop Failures</strong></p>
<p>The HX710B sensor used for measuring drum pressure occasionally gave erratic or drifting values, which caused:</p>
<ul>
<li><strong>Preemptive termination of water fill.</strong></li>
<li><strong>Overfilling with no cutoff.</strong></li>
</ul>
<p>I solved this <strong>by</strong>:</p>
<ul>
<li><strong>Stabilizing digital readings.</strong></li>
<li><strong>Averaging the values across multiple samples.</strong></li>
<li><strong>Introducing double-threshold hysteresis logic to avoid rapid toggling.</strong></li>
</ul>
<hr>
<p><strong>4. 🕒 Relay Changeover Interference with IPM</strong></p>
<p>The changeover relays used to reverse motor direction were affecting the IPM drive. During relay switching, the IPM would falsely detect a short circuit or open-load fault, triggering shutdown.</p>
<p>The <strong>solution</strong> involved:</p>
<ul>
<li><strong>Temporarily disabling PWM output just before switching the relay.</strong></li>
<li><strong>Adding short time delays (ms scale) to prevent logic conflicts.</strong></li>
</ul>
<hr>
<p><strong>5. ⏱️ Watchdog Timer Interrupts</strong></p>
<p>A mysterious reboot issue plagued the early firmware. The ESP32 would randomly reset, often during display status updates or Wi-Fi activity.
The culprit was the Watchdog Timer (WDT) triggered by a non-responsive LED status task.</p>
<p>I fixed <strong>this</strong> by:</p>
<ul>
<li><strong>Restructuring the task into non-blocking logic.</strong></li>
<li><strong>Feeding the watchdog manually at safe checkpoints.</strong></li>
</ul>
<hr>
<p><strong>6. 🚫 Spin Cycle Motor Lock Detection</strong></p>
<p>When the tub was filled with wet, heavy clothes, the motor would often fail to spin up. The IPM interpreted this as a motor lockup condition and shut off power immediately.</p>
<p>I <strong>resolved</strong> this by:</p>
<ul>
<li><strong>Altering the shunt resistor scaling.</strong></li>
<li><strong>Filtering out sudden current spikes that falsely triggered the OCP logic.</strong></li>
</ul>
<hr>
<p><strong>7. 🧺 Unbalanced Load During Spin Start</strong></p>
<p>After the rinse or wash cycle, once water drained and spin was initiated, the initial jerk caused imbalanced clothes to bang against the drum. The system lacked a low-speed balance detection mechanism <strong>because:</strong></p>
<ul>
<li><strong>The IPM Drive offered no 1 RPM-level fine control.</strong></li>
<li><strong>There was no gyroscope or vibration feedback loop.</strong></li>
</ul>
<p>The only permanent solution would be to design a custom inverter drive with full low-speed control and dynamic load balancing.</p>
<hr>
<p><strong>8. ⚡ Unexpected Inverter Shutdowns &amp; Self-Power-On Events</strong></p>
<p>Intermittently, the IPM module <strong>would:</strong></p>
<ul>
<li><strong>Shut down during phase changeovers.</strong></li>
<li><strong>Restart automatically after long delays, even when not commanded.</strong></li>
</ul>
<p>This erratic behavior was difficult to reproduce and remains partially unexplained — likely caused by internal auto-restart logic or control pin float issues. Proper pull-down resistors and debounce delays are planned for future fixes.</p>
<hr>
<p><strong>9. 🔄 Real-Time Water Level Monitoring Integration</strong></p>
<p>Developing a unified function that <strong>simultaneously:</strong></p>
<ul>
<li><strong>Monitored water level.</strong></li>
<li><strong>Triggered inlet control.</strong></li>
<li><strong>Prevented overflow.</strong></li>
<li><strong>Integrated manual override.</strong></li>
</ul>
<p>…was a huge design effort. It required nested conditions, multiple interrupt scenarios, and continual calibration.</p>
<hr>
<p><strong>10. 🖥️ User Interface Design &amp; Display Formatting</strong></p>
<p>Displaying system state on a 16x2 LCD (or I2C variant) turned out to be unexpectedly complex.
Challenges <strong>included:</strong></p>
<ul>
<li><strong>Fitting multiline prompts within 16 characters.</strong></li>
<li><strong>Preventing display flicker during rapid updates.</strong></li>
<li><strong>Designing a readable and intuitive menu/UI flow.</strong></li>
</ul>
<p>Each parameter shown — from current mode, to water level, to spin state — had to be dynamically refreshed without blocking the control loop.</p>
<hr>
<hr>
<h2 id="-final-system-behavior">🧼 Final System Behavior</h2>
<p>The final system, after extensive R&amp;D, testing, and integration, behaves as a fully self-regulating, smart IoT-based appliance. Designed with both manual and smart capabilities, the washing machine now performs autonomously — while also offering granular user feedback via physical indicators, LCD, and remote messaging.</p>
<p>Here’s a detailed description of how the system behaves from the moment it powers on to the completion of a wash program:</p>
<p><strong>🔌 1. Power-On Initialization</strong></p>
<p>Upon supplying power to the system, the green ring LED surrounding the main power button lights up steadily.
Simultaneously, the 16x2 LCD displays a welcome screen:</p>
<pre tabindex="0"><code>    Advanced IoT 
  Washing Machine
</code></pre><p>Four dedicated LEDs labeled Soak, Wash, Rinse, Spin illuminate briefly in a sweeping pattern to indicate boot sequence.
The ESP32 begins initializing all core modules — GPIOs, sensors, relays, display, and Wi-Fi stack.</p>
<hr>
<p><strong>📶 2. Wi-Fi Connectivity &amp; Smart Mode Check</strong></p>
<p>During Wi-Fi connection attempt, the green ring LED blinks at 1-second intervals, visually indicating that the system is attempting to go online.</p>
<p>If Wi-Fi is connected successfully:</p>
<ul>
<li>The ring LED turns solid green.</li>
<li>A boot success message is pushed via Telegram Bot API.</li>
<li>Smart features such as remote control, OTA, and voice assistant integration are enabled.</li>
</ul>
<p>If Wi-Fi fails:</p>
<p>The ring LED turns off.
The machine enters offline fallback mode where only manual control is available.</p>
<hr>
<p><strong>🧺 3. Program Selection Logic</strong></p>
<p>The user can press any of the physical buttons to select a program: Wash, Rinse, or Spin</p>
<p>Once a program is selected:</p>
<ul>
<li>The corresponding LED stays lit.</li>
</ul>
<p>A 10-second grace period is activated, during which:</p>
<ul>
<li>The user can cancel the operation or select a different mode.</li>
<li>If interrupted, all LEDs are reset, and system returns to idle.</li>
<li>After 10 seconds of no change, the selected program is locked in and begins execution.</li>
</ul>
<hr>
<p><strong>🚿 4. Water Filling &amp; Level Monitoring</strong></p>
<ul>
<li>Most programs begin with water intake via the solenoid inlet valve.</li>
<li>The HX710B pressure sensor reads real-time air pressure from the drum&rsquo;s air trap system.</li>
<li>The current water level (in liters) is displayed on the LCD.</li>
<li>Once the target level is reached, the inlet valve is turned off.</li>
</ul>
<p>✅ If Wi-Fi is active, a message is sent to the Telegram bot such as:</p>
<pre tabindex="0"><code>&#34;Program: Wash Started | Target Water: 12.0L&#34;
&#34;Filling... Current Level: 7.5L&#34;
</code></pre><hr>
<p><strong>🌀 5. Agitation, Rinse, and Spin Execution</strong></p>
<p>Based on selected mode, the drum is driven through timed sequences using:</p>
<ul>
<li>Directional control via changeover relays</li>
<li>Speed control via PWM signal to the inverter drive</li>
</ul>
<p>Modes:</p>
<ul>
<li>Soak: Fill Water and light movement of clothes over a long period of time.</li>
<li>Wash: Clockwise and counter-clockwise cycles with staggered delays.</li>
<li>Rinse: Refill water, agitate lightly, drain.</li>
<li>Spin: Full-speed single direction motor run with drain valve open.</li>
</ul>
<p>The LCD displays:</p>
<ul>
<li>Current stage (e.g., Washing: Stage 2 of 3).</li>
<li>Elapsed time.</li>
<li>System status or error if any.</li>
</ul>
<hr>
<p><strong>💬 6. Real-Time Remote Feedback</strong></p>
<p>During each stage transition or sensor threshold trigger, a status update is sent to Telegram:</p>
<pre tabindex="0"><code>&#34;Spin Cycle Started | RPM: 950 | Load: Balanced ✅&#34;
&#34;Rinse Completed | Drain: Successful&#34;
</code></pre><p>All telemetry is also recorded for later data analytics and visualization (future scope).</p>
<hr>
<p><strong>🧘 7. Post-Cycle &amp; Idle Mode</strong></p>
<p>Once the selected cycle is completed:</p>
<ul>
<li>All relays are turned off.</li>
<li>Inverter drive is disabled.</li>
<li>The final water level, wash duration, and energy usage are logged.</li>
</ul>
<p>A Telegram message confirms completion:</p>
<pre tabindex="0"><code>✅ Wash Cycle Completed
Total Water Used: 18.0L
Duration: 00:24:32
Power: 350W
</code></pre><ul>
<li>The machine then returns to idle mode, ready for the next input.</li>
<li>If left untouched, the system maintains low-power state and periodically checks for OTA updates or new commands.</li>
</ul>
<hr>
<hr>
<h2 id="-gallery--media">🖼️ Gallery &amp; Media</h2>
<p>Below are some photos and media captured during the 1-year long development and testing process of the smart washing machine retrofit project.</p>
<p>Click on the text, and it will lead to indivisual photos and videos inside the google Photos Album.
PS. These Links are <strong>completely</strong> SAFE!</p>
<hr>
<p><strong>1. 🧠 Reverse Engineering Process</strong></p>
<ul>
<li>
<p><a href="https://photos.google.com/share/AF1QipPNWp27gQstlgL91O9z6UTNsfqDp0jNiJFLL1oh2fxKv0CKhDPo4cSU1hQcb7W5Ug/photo/AF1QipNVxxiq89uGjgkWxa-xYKltjGWV_kP-2nztHGkK?key=WE9fbWNub0hjMVVGcDI5YVAwNG5lRzgwblA3Qm1B">IPM Drive Testing (Test 1)</a></p>
</li>
<li>
<p><a href="https://photos.google.com/share/AF1QipPNWp27gQstlgL91O9z6UTNsfqDp0jNiJFLL1oh2fxKv0CKhDPo4cSU1hQcb7W5Ug/photo/AF1QipOIaje6bVMC1V6RkXsUcQZVmSZkGwG7BSXOfMsF?key=WE9fbWNub0hjMVVGcDI5YVAwNG5lRzgwblA3Qm1B">IPM Drive Testing (Test2 )</a></p>
</li>
<li>
<p><a href="https://photos.google.com/share/AF1QipPNWp27gQstlgL91O9z6UTNsfqDp0jNiJFLL1oh2fxKv0CKhDPo4cSU1hQcb7W5Ug/photo/AF1QipPu-ZJu5S38M4Kw0cIc7J9eAKHDdguFzxUn6J73?key=WE9fbWNub0hjMVVGcDI5YVAwNG5lRzgwblA3Qm1B">IPM Drive Assembly Image 1</a></p>
</li>
<li>
<p><a href="https://photos.google.com/share/AF1QipPNWp27gQstlgL91O9z6UTNsfqDp0jNiJFLL1oh2fxKv0CKhDPo4cSU1hQcb7W5Ug/photo/AF1QipOtSMJzY3PqHMc3hq3MuFuZ1_jsQ_B-2PM2y5cD?key=WE9fbWNub0hjMVVGcDI5YVAwNG5lRzgwblA3Qm1B">IPM Drive Assembly Image 2</a></p>
</li>
<li>
<p><a href="https://photos.google.com/share/AF1QipPNWp27gQstlgL91O9z6UTNsfqDp0jNiJFLL1oh2fxKv0CKhDPo4cSU1hQcb7W5Ug/photo/AF1QipOttMqX2rKagrsjaFgf-D7oYPz6J4DbcodiPMrN?key=WE9fbWNub0hjMVVGcDI5YVAwNG5lRzgwblA3Qm1B">IPM Drive Assembly Image 3</a></p>
</li>
</ul>
<hr>
<p><strong>2. 🔌 Wiring &amp; Control Unit Assembly</strong></p>
<ul>
<li>
<p><a href="https://photos.google.com/share/AF1QipPNWp27gQstlgL91O9z6UTNsfqDp0jNiJFLL1oh2fxKv0CKhDPo4cSU1hQcb7W5Ug/photo/AF1QipPgxhnKn9E3zUT-M9a8fnucJ8l8pAPLddA-W4Z_?key=WE9fbWNub0hjMVVGcDI5YVAwNG5lRzgwblA3Qm1B">Custom Zero PCB Based Circuit</a></p>
</li>
<li>
<p><a href="https://photos.google.com/share/AF1QipPNWp27gQstlgL91O9z6UTNsfqDp0jNiJFLL1oh2fxKv0CKhDPo4cSU1hQcb7W5Ug/photo/AF1QipP3Pys3-RKjSYWpHMEyqI5ZrcNhQ54i70lSnye4?key=WE9fbWNub0hjMVVGcDI5YVAwNG5lRzgwblA3Qm1B">Custom Zero PCB Based Circuit (Image 2)</a></p>
</li>
<li>
<p><a href="https://photos.google.com/share/AF1QipPNWp27gQstlgL91O9z6UTNsfqDp0jNiJFLL1oh2fxKv0CKhDPo4cSU1hQcb7W5Ug/photo/AF1QipMZ5tE8bI7WuJttj-N1EQ8UQHf_NgoKKCd8Q22i?key=WE9fbWNub0hjMVVGcDI5YVAwNG5lRzgwblA3Qm1B">Custom Zero PCB (Soldering and Traces)</a></p>
</li>
<li>
<p><a href="https://photos.google.com/share/AF1QipPNWp27gQstlgL91O9z6UTNsfqDp0jNiJFLL1oh2fxKv0CKhDPo4cSU1hQcb7W5Ug/photo/AF1QipMZ5tE8bI7WuJttj-N1EQ8UQHf_NgoKKCd8Q22i?key=WE9fbWNub0hjMVVGcDI5YVAwNG5lRzgwblA3Qm1B">Custom Zero PCB (Soldering and Traces 2)</a></p>
</li>
<li>
<p><a href="https://photos.google.com/share/AF1QipPNWp27gQstlgL91O9z6UTNsfqDp0jNiJFLL1oh2fxKv0CKhDPo4cSU1hQcb7W5Ug/photo/AF1QipPnbMUKjz5iKp1NFaPk81gNh_66vLAZB7_8QVWX?key=WE9fbWNub0hjMVVGcDI5YVAwNG5lRzgwblA3Qm1B">Custom Zero PCB (Final Soldering Done)</a></p>
</li>
<li>
<p><a href="https://photos.google.com/share/AF1QipPNWp27gQstlgL91O9z6UTNsfqDp0jNiJFLL1oh2fxKv0CKhDPo4cSU1hQcb7W5Ug/photo/AF1QipNHd1usFwYlTc6EfW2EbeeGgLNA1Vyr7TrSQdnu?key=WE9fbWNub0hjMVVGcDI5YVAwNG5lRzgwblA3Qm1B">Custom Zero PCB Based Circuit (Test Run)</a></p>
</li>
</ul>
<hr>
<p><strong>3. 📟 Display &amp; UI</strong></p>
<ul>
<li>
<p><a href="https://photos.google.com/share/AF1QipPNWp27gQstlgL91O9z6UTNsfqDp0jNiJFLL1oh2fxKv0CKhDPo4cSU1hQcb7W5Ug/photo/AF1QipPRDzTbBiRYZB3S6eAQc1LLgfklFBrtY4y0V2xW?key=WE9fbWNub0hjMVVGcDI5YVAwNG5lRzgwblA3Qm1B">Front Panel ZERO PCB Design</a></p>
</li>
<li>
<p><a href="https://photos.google.com/share/AF1QipPNWp27gQstlgL91O9z6UTNsfqDp0jNiJFLL1oh2fxKv0CKhDPo4cSU1hQcb7W5Ug/photo/AF1QipMNQk_vXrH9MxTog7xU1b5WL2NTypNCzGVLaq9m?key=WE9fbWNub0hjMVVGcDI5YVAwNG5lRzgwblA3Qm1B">Front Panel Working Video)</a></p>
</li>
<li>
<p><a href="https://photos.google.com/share/AF1QipPNWp27gQstlgL91O9z6UTNsfqDp0jNiJFLL1oh2fxKv0CKhDPo4cSU1hQcb7W5Ug/photo/AF1QipMa1f6072fTf-P5mK3TROiZc0dYj_0-kzBQliSJ?key=WE9fbWNub0hjMVVGcDI5YVAwNG5lRzgwblA3Qm1B">Front Panel Zero PCB (Soldering and Traces 2)</a></p>
</li>
<li>
<p><a href="https://photos.google.com/share/AF1QipPNWp27gQstlgL91O9z6UTNsfqDp0jNiJFLL1oh2fxKv0CKhDPo4cSU1hQcb7W5Ug/photo/AF1QipMa1f6072fTf-P5mK3TROiZc0dYj_0-kzBQliSJ?key=WE9fbWNub0hjMVVGcDI5YVAwNG5lRzgwblA3Qm1B">Front Panel Zero PCB Based Circuit</a></p>
</li>
</ul>
<hr>
<p><strong>4. 🌀 Mechanical Testing</strong></p>
<ul>
<li><a href="https://photos.google.com/share/AF1QipPNWp27gQstlgL91O9z6UTNsfqDp0jNiJFLL1oh2fxKv0CKhDPo4cSU1hQcb7W5Ug/photo/AF1QipOLuU6hPTdLg9m6AT2BRDVsX4j-P8UZuohC88_P?key=WE9fbWNub0hjMVVGcDI5YVAwNG5lRzgwblA3Qm1B">Load Testing</a></li>
</ul>
<hr>
<p><strong>5. 📹 Video Demonstration</strong></p>
<ul>
<li>
<p><a href="https://photos.google.com/share/AF1QipPNWp27gQstlgL91O9z6UTNsfqDp0jNiJFLL1oh2fxKv0CKhDPo4cSU1hQcb7W5Ug/photo/AF1QipMSRp5zz-8cOHieEaOTm9mBGuAuogwmykCte0QY?key=WE9fbWNub0hjMVVGcDI5YVAwNG5lRzgwblA3Qm1B">Final Working Demo (Internals Shown)</a></p>
</li>
<li>
<p><a href="https://photos.google.com/share/AF1QipPNWp27gQstlgL91O9z6UTNsfqDp0jNiJFLL1oh2fxKv0CKhDPo4cSU1hQcb7W5Ug/photo/AF1QipPZ5GAmqaRBAopp11-z1agipSMxAAhcM-O3ojQL?key=WE9fbWNub0hjMVVGcDI5YVAwNG5lRzgwblA3Qm1B">Final Working Demo (Spin Mode Via Voice Assistant)</a></p>
</li>
<li>
<p><a href="https://photos.google.com/share/AF1QipPNWp27gQstlgL91O9z6UTNsfqDp0jNiJFLL1oh2fxKv0CKhDPo4cSU1hQcb7W5Ug/photo/AF1QipPZ5GAmqaRBAopp11-z1agipSMxAAhcM-O3ojQL?key=WE9fbWNub0hjMVVGcDI5YVAwNG5lRzgwblA3Qm1B">Final Working Demo (Spin Mode Via Voice Assistant)</a></p>
</li>
<li>
<p><a href="https://photos.google.com/share/AF1QipPNWp27gQstlgL91O9z6UTNsfqDp0jNiJFLL1oh2fxKv0CKhDPo4cSU1hQcb7W5Ug/photo/AF1QipMhjJPm_ThSKVRP6Tn-dtEaeav-43ltuXjk5MuQ?key=WE9fbWNub0hjMVVGcDI5YVAwNG5lRzgwblA3Qm1B">Internal Construction</a></p>
</li>
</ul>
<p>Refer to this Google Photos Album for more Behind The Scenes Footage:</p>
<ul>
<li><a href="https://photos.app.goo.gl/JXmmXoFTdbAtJn859">Google Photos</a></li>
</ul>
<hr>
<hr>
<h2 id="-source-code--documents-folder">💾 Source Code &amp; Documents Folder</h2>
<ol>
<li>The full source code is available on GitHub and includes:</li>
</ol>
<ul>
<li>ESP32 firmware (ESP-IDF/Arduino)</li>
<li>WiFi + OTA + Telegram setup</li>
<li>HX710B sensor calibration logic</li>
<li>PWM timing sequence for IPM drive</li>
</ul>
<blockquote>
<p>🔗 <strong><a href="https://github.com/atharvap8/Advanced-IoT-Washing-Machine">GitHub Repository: github.com/atharvap8/Advanced-IoT-Washing-Machine</a></strong></p></blockquote>
<ol start="2">
<li>Full Documentation Archive (Schematics, PCB, Code)</li>
</ol>
<p>Includes all schematic files, PCB layouts, firmware source code, block diagrams, wiring charts, and reference images.</p>
<blockquote>
<p>🔗 <strong><a href="https://drive.google.com/drive/folders/1uPgTiL8me0PxTM-ofMAjB7GyhWTrKcd5?usp=sharing">Google Drive Folder: drive.google.com/drive/folders/1uPgTiL8me0PxTM-ofMAjB7GyhWTrKcd5?usp=sharing</a></strong></p></blockquote>
<p>Contents of the folder:</p>
<ul>
<li>📄 Schematics/ — All connections (ESP32, relays, IPM drive, sensors)</li>
<li>🧩 PCB Designs/ — KiCAD or EasyEDA layouts + Gerbers</li>
<li>⚙️ ESP32_Firmware/ — Main firmware source (OTA, Telegram, HX710B)</li>
<li>🖼️ Diagrams/ — High-level architecture of the machine</li>
<li>🧠 Partition Layout — ESP32 Partition Layout file</li>
<li>🧪 Research - All the research on IPM Drives, and 3-Phase Motor Control</li>
</ul>
<hr>
]]></content></item><item><title>Home Automation 15 Devices</title><link>https://atharvap8.github.io/posts/2024/06/home-automation-15-devices/</link><pubDate>Sun, 02 Jun 2024 17:57:12 +0530</pubDate><guid>https://atharvap8.github.io/posts/2024/06/home-automation-15-devices/</guid><description>&lt;h1 id="smart-home-system-with-esp32-alexa-control-and-eeprom-state-retention">Smart Home System with ESP32, Alexa Control, and EEPROM State Retention&lt;/h1>
&lt;hr>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>In this project, we will create a smart home system that allows control over 14 devices and 1 air conditioner (AC) using an ESP32 microcontroller. The system includes EEPROM functionality, which retains the state of all devices even after a sudden power loss. With Alexa integration, users can control lights, fans, tube lights, AC, and more using voice commands and monitor the real-time status through the Alexa app. Each room is equipped with a 4-channel relay module, connected to a central controller that manages all relays.&lt;/p></description><content type="html"><![CDATA[<h1 id="smart-home-system-with-esp32-alexa-control-and-eeprom-state-retention">Smart Home System with ESP32, Alexa Control, and EEPROM State Retention</h1>
<hr>
<h2 id="introduction">Introduction</h2>
<p>In this project, we will create a smart home system that allows control over 14 devices and 1 air conditioner (AC) using an ESP32 microcontroller. The system includes EEPROM functionality, which retains the state of all devices even after a sudden power loss. With Alexa integration, users can control lights, fans, tube lights, AC, and more using voice commands and monitor the real-time status through the Alexa app. Each room is equipped with a 4-channel relay module, connected to a central controller that manages all relays.</p>
<p>This project is ideal for automating homes and integrating voice-controlled systems, making life easier and more efficient.</p>
<hr>
<h2 id="components-required">Components Required</h2>
<p>To build this smart home system, you’ll need the following components:</p>
<ul>
<li>ESP32 (central controller with Wi-Fi functionality)</li>
<li>4-Channel Relay Modules (one per room)</li>
<li>EEPROM (to store device states)</li>
<li>Alexa-compatible devices (for voice control)</li>
<li>AC Module (for controlling air conditioner)</li>
<li>Power Supply (5V and 12V as required)</li>
<li>Jumper Wires</li>
<li>Connectors</li>
<li>PCB for custom circuit design (optional)</li>
<li>Resistors, Capacitors, Diodes, etc.</li>
<li>Breadboard for testing</li>
</ul>
<hr>
<h2 id="raw-media-files">Raw Media Files</h2>
<p>These are the raw unedited photos, videos, and prototype tests. Click Here:</p>
<p><a href="https://photos.app.goo.gl/MDPgTyUHdiMzcUrm7"><img src="https://img.shields.io/badge/GooglePhotos-Album-blue?style=flat&amp;logo=Google%20Photos" alt="Static Badge"></a></p>
<hr>
<h2 id="how-it-works">How It Works</h2>
<p>The ESP32 serves as the main controller for the entire smart home system. Each room has a 4-channel relay module, which controls the devices (e.g., lights, fans, etc.). The ESP32 sends signals to the relay modules based on user commands.</p>
<p>Key features include:</p>
<ol>
<li><strong>Voice Control:</strong> Integrated with Alexa, users can control devices using voice commands.</li>
<li><strong>Real-time Monitoring:</strong> The status of each device is displayed and controlled through the Alexa app.</li>
<li><strong>EEPROM Functionality:</strong> In case of a power failure, the system retains the state of each device, ensuring continuity once power is restored.</li>
<li><strong>Centralized Control:</strong> A central controller manages all room relays, reducing wiring complexity and enabling seamless communication between rooms.</li>
</ol>
<hr>
<h2 id="step-by-step-making-guide">Step-by-Step Making Guide</h2>
<h3 id="step-1-gather-components">Step 1: Gather Components</h3>
<p>Collect all the components listed above, ensuring you have an ESP32, relay modules, EEPROM, and Alexa-compatible devices.</p>
<h3 id="step-2-build-the-circuit-prototype">Step 2: Build the Circuit Prototype</h3>
<p>Start by connecting the ESP32 to the 4-channel relay modules. Wire each room’s module to the central ESP32 controller. Ensure proper connections for the EEPROM and power supply.</p>
<h3 id="step-3-program-the-esp32">Step 3: Program the ESP32</h3>
<p>Using Arduino IDE or any other compatible platform, upload the code to the ESP32. The code should include the logic for relay control, Alexa voice integration, and EEPROM state retention.
[Insert code or link to code here]</p>
<h3 id="step-4-connect-to-alexa">Step 4: Connect to Alexa</h3>
<p>Set up the ESP32 to communicate with Alexa. You can use platforms like AWS IoT or ESP Alexa libraries. Ensure that each device (fan, light, etc.) is properly recognized in the Alexa app for voice and app control.</p>
<h3 id="step-5-test-the-system">Step 5: Test the System</h3>
<p>Once everything is connected, test each room by controlling devices with voice commands and the Alexa app. Ensure that the EEPROM correctly restores the device states after a power cut.</p>
<h3 id="step-6-design-and-assemble-the-pcb">Step 6: Design and Assemble the PCB</h3>
<p>After testing the prototype, move to PCB design for a more permanent solution. Assemble the components onto the PCB and test the system again.</p>
<hr>
<h2 id="conclusion">Conclusion</h2>
<p>This smart home system provides efficient, centralized control over various home appliances and devices. With features like Alexa voice control and real-time monitoring, the system offers a modern and convenient solution for home automation. The EEPROM functionality ensures device state retention, making the system reliable even in power outages.</p>
<hr>
<h2 id="advantages">Advantages</h2>
<ul>
<li>Centralized control over 14 devices and 1 AC unit.</li>
<li>Alexa voice control and real-time status monitoring via the Alexa app.</li>
<li>EEPROM functionality retains device states after power loss.</li>
<li>Modular relay system for easy expansion and customization.</li>
<li>Simple, user-friendly control interface through voice commands.</li>
</ul>
<hr>
<h2 id="disadvantages">Disadvantages</h2>
<ul>
<li>Complex initial setup due to wiring and Alexa integration.</li>
<li>Requires reliable Wi-Fi for Alexa and real-time monitoring.</li>
<li>Limited to 14 devices unless more relays are added.</li>
</ul>
<hr>
<h2 id="future-scope-for-improvement">Future Scope for Improvement</h2>
<ul>
<li>Expand the number of devices controlled by adding more relay modules.</li>
<li>Integrate with other smart home platforms like Google Home or HomeKit.</li>
<li>Add support for remote control via mobile apps outside the Alexa ecosystem.</li>
<li>Improve power efficiency and incorporate energy-saving mechanisms for smart devices.</li>
<li>Battery backup to maintain system operation during power outages.</li>
</ul>
<hr>
]]></content></item></channel></rss>